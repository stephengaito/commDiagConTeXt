% A ConTeXt document [master document: commdiag.tex]

\startchapter[title=Macros]

\startMkIVCode

\defineMPinstance
  [commDiag]
  [
    format=metafun,
    extensions=yes,
    initializations=yes,
    method=double
  ]
  
\startMPdefinitions{commDiag}
  def setupCommDiags = 
    picture objLabel[][];
    pair objPos[][];
    numeric numRows; numRows := 0;
    numeric numCols; numCols := 0;
  enddef ;

  def updateRowsCols(expr i, j) =
    if numRows < i : numRows := i; fi ;
    if numCols < j : numCols := j; fi ;
  enddef;
  
  def checkRowsCols(expr i, j) =
    if (i < 1) or
      (numRows < i) or
      (j < 1) or
      (numCols < j) :
      message("numRows = "&decimal numRows);
      message("numCols = "&decimal numCols);
      errmessage("incorrect row or column in ("&decimal i&", "&decimal j&")!");
    fi;
  enddef;
  
  def addObject(expr row, col, aLabel) text allText =
    updateRowsCols(row, col);
    objLabel[row][col] := image(
      label("$"&aLabel&"$", origin) allText;
    ) ;
  enddef ;

  def drawObjects(expr rowHeight, colWidth) = 
    for i = 1 upto numRows : 
      for j = 1 upto numCols :
        objPos[i][j] = (j*colWidth, (-i)*rowHeight);
        if known(objLabel[i][j]) :
          objLabel[i][j] := objLabel[i][j] shifted objPos[i][j];
          draw objLabel[i][j];
        fi ;
      endfor;
    endfor;
  enddef;

  % The following squiggles are based on Thurston's answer to
  %   "How to create a wavy lines with MetaPost?"
  % see: https://tex.stackexchange.com/a/162406
  %
  % Be reasonable with these lengths.  If you use `drawarrow` then 
  % you should ensure that s_lambda > ahlength

  newinternal sArrowLambda, sArrowAngle;
  sArrowLambda := 6;  % the length of the waves
  sArrowAngle  := 45; % the angle of attack 

  vardef sinuousArrow expr p = 
    save ut, numUT; numeric ut, numUT;    
    ut    := arctime sArrowLambda of p;
    numUT := floor(length p / ut) ;
    point 0 of p --
    point ut of p {curl 0} ..
      for i=2 step 2 until numUT-3:
        point     i*ut of p
          { (direction     i*ut of p) rotated +sArrowAngle } ..
        point (i+1)*ut of p
          { (direction (i+1)*ut of p) rotated -sArrowAngle } ..
      endfor
    { direction length p of p } point ((numUT-1)*ut) of p --
    point length(p) of p
  enddef;

  newinternal z_lambda, z_amp;
  zArrowLambda := 6;   % the length of the zig-zags
  zArrowAmp    := 2.4; % the amplitude of each zig and zag

  vardef ziggyArrow expr p = 
    save ut, numUT; numeric ut, numUT;    
    ut    := arctime zArrowLambda of p;
    numUT := floor(length p / ut) ;
    point 0 of p -- point ut of p --
      for i=2 step 2 until numUT-3:
        point     i*ut of p +
          zArrowAmp*up   rotated angle direction     i*ut of p --
        point (i+1)*ut of p +
          zArrowAmp*down rotated angle direction (i+1)*ut of p --
      endfor
    point (numUT-1)*ut of p -- point length p of p
  enddef;
  
  newinternal equalArrowShift;
  equalArrowShift := 1bp ;
    
  % Based on the definition of "arrowhead" 
  % in file tex/texmf/metapost/base/plain.mp 
  % in the ConTeXt experimental distribution.
  % Taken on 10 August 2018.
  % The file's header is:
  %
  %% % $Id: plain.mp,v 1.3 2005/04/28 06:45:21 taco Exp $
  %% % Public domain.
  %

  newinternal sahFraction;
  sahFraction := 0.9; % default second arrowhead point 90% of arrow path
  
  %% Forward arrow heads/tails ...
  
  vardef firstArrowHead expr p =
    save q,e; path q; pair e;
    e := point length p of p;
    q := gobble(p shifted -e cutafter makepath(pencircle scaled 2ahlength))
      cuttings;
    (q rotated .5ahangle & reverse q rotated -.5ahangle -- cycle)  shifted e
  enddef;
  
  vardef secondArrowHead expr p =
    save q, e; path q; pair e;
    e := point (sahFraction*length p) of p;
    q := gobble(
      subpath (0, (sahFraction*length p)) of p shifted -e 
      cutafter makepath(pencircle scaled 2ahlength)
    ) cuttings;
    (q rotated .5ahangle & reverse q rotated -.5ahangle -- cycle)  shifted e
  enddef;
  
  vardef firstArrowTail expr p =
    save q,eA, eB; path q; pair eA, eB;
    eA := point 0 of p;
    q := gobble(p shifted -eA cutbefore makepath(pencircle scaled 2ahlength))
      cuttings;
    eB := point length(q) of q;
    q := q shifted -eB ;
    (q rotated .5ahangle & reverse q rotated -.5ahangle -- cycle)
      shifted (eA + eB)
  enddef;
  
  vardef secondArrowTail expr p =
    save q,eA, eB, aFraction; path q; pair eA, eB; numeric aFraction;
    aFraction := 2*(1.0 - sahFraction);
    eA := point (aFraction * length p) of p;
    q := gobble(
      subpath (0, (aFraction * length p)) of p shifted -eA
      cutafter makepath(pencircle scaled 2ahlength)
    ) cuttings;
    eB := point length(q) of q;
    q := q shifted -eB ;
    (q rotated .5ahangle & reverse q rotated -.5ahangle -- cycle)
      shifted (eA + eB)
  enddef;

  %% Reversed arrow heads/tails ...
  
  vardef firstReversedArrowHead expr p =
    save q, eA, eB; path q; pair eA, eB;
    eA := point length p of p;
    q := gobble(
      p shifted -eA 
      cutafter makepath(pencircle scaled 2ahlength)
    ) cuttings;
    eB := point 0 of q ;
    q := q shifted -eB ;
    ( reverse q rotated .5ahangle & q rotated -.5ahangle -- cycle)
      shifted (eA + eB)
  enddef;

  vardef secondReversedArrowHead expr p =
    save q, eA, eB; path q; pair eA, eB;
    eA := point (sahFraction*length p) of p;
    q := gobble(
      subpath (0, (sahFraction*length p)) of p shifted -eA 
      cutafter makepath(pencircle scaled 2ahlength)
    ) cuttings;
    eB := point 0 of q ;
    q := q shifted -eB ;
    (reverse q rotated .5ahangle & q rotated -.5ahangle -- cycle)
      shifted (eA + eB)
  enddef;

  vardef firstReversedArrowTail expr p =
    save q,eA, eB; path q; pair eA, eB;
    eA := point 0 of p;
    q := gobble(
      p shifted -eA
      cutbefore makepath(pencircle scaled 2ahlength)
    ) cuttings;
    (reverse q rotated .5ahangle & q rotated -.5ahangle -- cycle)
      shifted eA
  enddef;
  
  vardef secondReversedArrowTail expr p =
    save q,eA, eB, aFraction; path q; pair eA, eB; numeric aFraction;
    aFraction := 2*(1.0 - sahFraction);
    eA := point (aFraction * length p) of p;
    q := gobble(
      subpath (0, (aFraction * length p)) of p shifted -eA
      cutafter makepath(pencircle scaled 2ahlength)
    ) cuttings;
    eB := point 0 of q;
    q := q shifted -eB ;
    ( reverse q rotated .5ahangle & q rotated -.5ahangle -- cycle)
      shifted (eA + eB)
  enddef;
  
  %% Dot heads/tails ...
  
  vardef dotHead expr p =
    save q,eA,eB; path q; pair eA, eB;
    eA := point length p of p;
    eB := p shifted -eA intersectionpoint makepath(pencircle scaled ahlength) ;
    makepath(pencircle scaled ahlength) shifted (eA+eB)
  enddef;
  
  vardef dotTail expr p =
    save q,eA,eB; path q; pair eA, eB;
    eA := point 0 of p;
    eB := p shifted -eA intersectionpoint makepath(pencircle scaled ahlength) ;
    makepath(pencircle scaled ahlength) shifted (eA+eB)
  enddef;

  %% Bar heads/tails ...
  
  vardef barHead expr p =
    save q,e; path q; pair e;
    e := point length p of p;
    q := gobble(
      p shifted -e scaled 100
      cutafter makepath(pencircle scaled 2ahlength)
    ) cuttings;
    (q rotated 90 & reverse q rotated 270) shifted e
  enddef;

  vardef barTail expr p =
    save q,e; path q; pair e;
    e := point 0 of p;
    q := gobble(
      p shifted -e scaled 100
      cutbefore makepath(pencircle scaled 2ahlength)
    ) cuttings;
    (reverse q rotated 90 & q rotated 270) shifted e
  enddef;
  
  vardef drawArrowLabel
    (expr aLabel, labelPositionExpr)
    (suffix labelSuffix)
    (expr anArrow)
    text allText =
    %
    save imageLabel;
    picture imageLabel;
    %
    if numeric(labelPositionExpr) :
      if (labelPositionExpr) <= 0 :
        labelPosition := 0.5 ;
      elseif (labelPositionExpr) >= 1 :
        labelPosition := 0.5
      else :
        labelPosition := labelPositionExpr ;
      fi ;
    else :
      labelPosition := 0.5;
    fi ;
    if 0 < length(aLabel) :
      imageLabel := image(
        label labelSuffix (
          thelabel("$"&aLabel&"$", origin ) ,
          point labelPosition*length(anArrow) of anArrow
        ) allText ;
      );
      unfill bbox imageLabel;
      draw imageLabel;
    fi;
  enddef;
    
  % The "drawarrow" implementation is based upon that in plain.mp (see above)
  %
  vardef addArrow
    (expr fRow, fCol, tRow, tCol)
    (expr arrowDecorations, bend)
    (text bodyText)
    (text arrowText)
    (expr aLabel, labelPositionExpr)
    (suffix labelSuffix)
    text allText =
    %
    save aTail, aHead, outAngle, labelPosition;
    save fromTails, body, toHeads;
    save barAdjust;
    save anArrow;
    %
    numeric aTail, aHead, outAngle, labelPosition;
    string fromTails, body, toHeads;
    pair barAdjust;
    path anArrow;
    %
    checkRowsCols(fRow, fCol);
    checkRowsCols(tRow, tCol);
    %
    outAngle := angle (objPos[tRow][tCol] - objPos[fRow][fCol]);
    anArrow := 
      objPos[fRow][fCol]{dir (outAngle+bend)} .. 
      {dir (outAngle-bend)}objPos[tRow][tCol];
    if known(objLabel[fRow][fCol]) :
      anArrow :=
        anArrow cutbefore
        objLabel[fRow][fCol] enlarged 0.15cm ;
    fi ;
    if known(objLabel[tRow][tCol]) :
      anArrow :=
        anArrow cutafter
        objLabel[tRow][tCol] enlarged 0.15cm ;
    fi ;
    %
    % a local "drawarrow" implementation
    %
    if string(arrowDecorations) :
      save startBody, aChar; numeric startBody, aChar;
      startBody  := -1;
      for i = 1 upto length(arrowDecorations) :
        aChar := ASCII substring (i-1,i) of arrowDecorations ; 
        if aChar = 45 : % "-"
          startBody := i;
        elseif aChar = 61 : % "="
          startBody := i;
        elseif aChar = 126 : % "~"
          startBody := i;
        elseif aChar = 94 : % "^"
          startBody := i;
        fi ;
      endfor ; 
      if 0 < startBody :
        fromTails := 
          substring (0, startBody-1)
          of arrowDecorations ;
        body      :=
          substring (startBody-1, startBody)
          of arrowDecorations ;
        toHeads   := 
          substring (startBody, length(arrowDecorations)) 
          of arrowDecorations ;
      else : 
        fromTails := "";
        body      := "-";
        toHeads   := arrowDecorations;
      fi ;
    else :
      fromTails := "";
      body      := "-";
      toHeads   := ">";
    fi ;
    %
    barAdjust := (0,0);
    if body = "-" :
      draw anArrow bodyText allText ; 
    elseif body = "=" :
      barAdjust := 3*unitvector(direction 0 of anArrow);
      equalsShortenA := arctime 3*equalArrowShift of anArrow ;
      equalsShortenB := length(anArrow) - equalsShortenA ;
      draw subpath (equalsShortenA, equalsShortenB) of anArrow
        shifted (
          equalArrowShift *
          unitvector((direction 0 of anArrow) rotated 90)
        )
        bodyText allText ;
      draw subpath (equalsShortenA, equalsShortenB) of anArrow
        shifted (
          -equalArrowShift *
          unitvector((direction 0 of anArrow) rotated 90)
        )
        bodyText allText ;
      interim ahlength := 2*ahlength;
    elseif body = "~" :
      draw sinuousArrow anArrow bodyText allText ;
    elseif body = "^" :
      draw ziggyArrow anArrow bodyText allText ;
    else :
      draw anArrow allText ; 
    fi;
    %
    if 0 < length(fromTails) :
      for i = 1 upto length(fromTails) :
        aTail := ASCII (substring(i-1,i) of fromTails);
        if aTail = 124 : % "|"
          draw barTail anArrow
            shifted barAdjust
            arrowText allText ;
        elseif aTail = 111 : % "o"
          filldraw dotTail anArrow arrowText allText ;
        elseif aTail = 62 : % ">"
          filldraw firstArrowTail anArrow arrowText allText ;
        elseif aTail = 60 : % "<"
          filldraw firstReversedArrowTail anArrow arrowText allText ;
        elseif aTail = 93 : % "]"
          filldraw secondArrowTail anArrow arrowText allText ;
        elseif aTail = 91 : % "["
          filldraw secondReversedArrowTail anArrow arrowText allText ;
        fi ;
      endfor ;
    fi ;
    %
    if 0 < length(toHeads) :
      for i = 1 upto length(toHeads) :
        aHead := ASCII (substring(i-1,i) of toHeads);
        if aHead = 124 : % "|" 
          draw barHead anArrow
            shifted -barAdjust
            arrowText allText ;
        elseif aHead = 111 : % "o"
          filldraw dotHead anArrow arrowText allText ;
        elseif aHead = 62 : % ">"
          filldraw firstArrowHead anArrow arrowText allText ;
        elseif aHead = 60 : % "<"
          filldraw firstReversedArrowHead anArrow arrowText allText ;
        elseif aHead = 93 : % "]"
          filldraw secondArrowHead anArrow arrowText allText ;
        elseif aHead = 91 : % "["
          filldraw secondReversedArrowHead anArrow arrowText allText ;
        fi ;
      endfor ;
    fi ;
    %
    drawArrowLabel(aLabel, labelPositionExpr, labelSuffix, anArrow) allText ;
  enddef;
\stopMPdefinitions

\stopMkIVCode

\startMpIVCode

message("Loaded Commutative Diagram MetaPost definitions") ;

\stopMpIVCode

\stopchapter