% A ConTeXt MkIV module

% from file: preamble.tex after line: 0

%D \module
%D   [     file=t-commdiag,
%D      version=2018.08.07,
%D        title=\CONTEXT\ User module,
%D     subtitle=Commutative Diagrams for \ConTeXt\,
%D       author=Stephen Gaito,
%D         date=\currentdate,
%D    copyright=PerceptiSys Ltd (Stephen Gaito),
%D        email=stephen@perceptisys.co.uk,
%D      license=MIT License]

%C Copyright (C) 2018 PerceptiSys Ltd (Stephen Gaito)
%C
%C Permission is hereby granted, free of charge, to any person obtaining a
%C copy of this software and associated documentation files (the
%C "Software"), to deal in the Software without restriction, including
%C without limitation the rights to use, copy, modify, merge, publish,
%C distribute, sublicense, and/or sell copies of the Software, and to
%C permit persons to whom the Software is furnished to do so, subject to
%C the following conditions:
%C
%C The above copyright notice and this permission notice shall be included
%C in all copies or substantial portions of the Software.
%C
%C THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
%C OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
%C MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
%C IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
%C CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
%C TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
%C SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

% begin info
%
% title   : Commutative Diagrams for ConTeXt
% comment : Provides structured document and code generation
% status  : under development, mkiv only
%
% end info

% the following IMMEDIATELY loads our t-commdiag.mpiv file into EVERY
% instance which allows extensions
%
%\startMPextensions
%  input t-commdiag.mpiv
%\stopMPextensions

% the following (dealayed) loads our t-commdiag.mpiv file into ONLY the
% metafun (default) instance.
%
\startMPdefinitions {metafun}
    if unknown commdiag_macros : input t-commdiag.mpiv ; fi ;
\stopMPdefinitions

% from file: preamble.tex after line: 50

\usemodule[literate-progs]

\unprotect

\ctxloadluafile{t-commdiag}

% from file: macros.tex after line: 0

\defineMPinstance
  [commDiag]
  [
    format=metafun,
    extensions=yes,
    initializations=yes,
    method=double
  ]
 
\startMPdefinitions{commDiag}
  def setupCommDiags =
    picture objLabel[][];
    picture arrLabel[][][][];
    numeric hasArrow[][][][];
    string aPos[][][][];
    pair w[][];
    path aLine;
    pair aBegin;
    pair aEnd;
    numeric numRows; numRows := 0;
    numeric numCols; numCols := 0;
  enddef ;

  def updateRowsCols(expr i, j) =
    if numRows < i : numRows := i; fi ;
    if numCols < j : numCols := j; fi ;
  enddef;
 
  def addObject(expr row, col, aLabel) =
    updateRowsCols(row, col);
    objLabel[row][col] := thelabel("$"&aLabel&"$", origin);
  enddef ;

  def drawObjects(expr rowWidth, colWidth) =
    for i = 1 upto numRows :
      for j = 1 upto numCols :
        w[i][j] = (j*colWidth*cm, (-i)*rowWidth*cm);
        objLabel[i][j] := objLabel[i][j] shifted w[i][j];
        draw objLabel[i][j];
      endfor;
    endfor;
  enddef;
 
  % Based on the definition of "arrowhead"
  % in file tex/texmf/metapost/base/plain.mp
  % in the ConTeXt experimental distribution.
  % Taken on 10 August 2018.
  % The file's header is:
  %
  %% % $Id: plain.mp,v 1.3 2005/04/28 06:45:21 taco Exp $
  %% % Public domain.
  %

  newinternal sahFraction;
  sahFraction := 0.9; % default second arrowhead point 90% of arrow path
 
  %% Forward arrow heads/tails ...
 
  vardef firstArrowHead expr p =
    save q,e; path q; pair e;
    e := point length p of p;
    q := gobble(p shifted -e cutafter makepath(pencircle scaled 2ahlength))
      cuttings;
    (q rotated .5ahangle & reverse q rotated -.5ahangle -- cycle)  shifted e
  enddef;
 
  vardef secondArrowHead expr p =
    save q, e; path q; pair e;
    e := point (sahFraction*length p) of p;
    q := gobble(
      subpath (0, (sahFraction*length p)) of p shifted -e
      cutafter makepath(pencircle scaled 2ahlength)
    ) cuttings;
    (q rotated .5ahangle & reverse q rotated -.5ahangle -- cycle)  shifted e
  enddef;
 
  vardef firstArrowTail expr p =
    save q,eA, eB; path q; pair eA, eB;
    eA := point 0 of p;
    q := gobble(p shifted -eA cutbefore makepath(pencircle scaled 2ahlength))
      cuttings;
    eB := point length(q) of q;
    q := q shifted -eB ;
    (q rotated .5ahangle & reverse q rotated -.5ahangle -- cycle)
      shifted (eA + eB)
  enddef;
 
  vardef secondArrowTail expr p =
    save q,eA, eB, aFraction; path q; pair eA, eB; numeric aFraction;
    aFraction := 2*(1.0 - sahFraction);
    eA := point (aFraction * length p) of p;
    q := gobble(
      subpath (0, (aFraction * length p)) of p shifted -eA
      cutafter makepath(pencircle scaled 2ahlength)
    ) cuttings;
    eB := point length(q) of q;
    q := q shifted -eB ;
    (q rotated .5ahangle & reverse q rotated -.5ahangle -- cycle)
      shifted (eA + eB)
  enddef;

  %% Reversed arrow heads/tails ...
 
  vardef firstReversedArrowHead expr p =
    save q, eA, eB; path q; pair eA, eB;
    eA := point length p of p;
    q := gobble(
      p shifted -eA
      cutafter makepath(pencircle scaled 2ahlength)
    ) cuttings;
    eB := point 0 of q ;
    q := q shifted -eB ;
    ( reverse q rotated .5ahangle & q rotated -.5ahangle -- cycle)
      shifted (eA + eB)
  enddef;

  vardef secondReversedArrowHead expr p =
    save q, eA, eB; path q; pair eA, eB;
    eA := point (sahFraction*length p) of p;
    q := gobble(
      subpath (0, (sahFraction*length p)) of p shifted -eA
      cutafter makepath(pencircle scaled 2ahlength)
    ) cuttings;
    eB := point 0 of q ;
    q := q shifted -eB ;
    (reverse q rotated .5ahangle & q rotated -.5ahangle -- cycle)
      shifted (eA + eB)
  enddef;

  vardef firstReversedArrowTail expr p =
    save q,eA, eB; path q; pair eA, eB;
    eA := point 0 of p;
    q := gobble(
      p shifted -eA
      cutbefore makepath(pencircle scaled 2ahlength)
    ) cuttings;
    (reverse q rotated .5ahangle & q rotated -.5ahangle -- cycle)
      shifted eA
  enddef;
 
  vardef secondReversedArrowTail expr p =
    save q,eA, eB, aFraction; path q; pair eA, eB; numeric aFraction;
    aFraction := 2*(1.0 - sahFraction);
    eA := point (aFraction * length p) of p;
    q := gobble(
      subpath (0, (aFraction * length p)) of p shifted -eA
      cutafter makepath(pencircle scaled 2ahlength)
    ) cuttings;
    eB := point 0 of q;
    q := q shifted -eB ;
    ( reverse q rotated .5ahangle & q rotated -.5ahangle -- cycle)
      shifted (eA + eB)
  enddef;
 
  %% Dot heads/tails ...
 
  vardef dotHead expr p =
    save q,eA,eB; path q; pair eA, eB;
    eA := point length p of p;
    eB := p shifted -eA intersectionpoint makepath(pencircle scaled ahlength) ;
    makepath(pencircle scaled ahlength) shifted (eA+eB)
  enddef;
 
  vardef dotTail expr p =
    save q,eA,eB; path q; pair eA, eB;
    eA := point 0 of p;
    eB := p shifted -eA intersectionpoint makepath(pencircle scaled ahlength) ;
    makepath(pencircle scaled ahlength) shifted (eA+eB)
  enddef;

  %% Bar heads/tails ...
 
  vardef barHead expr p =
    save q,e; path q; pair e;
    e := point length p of p;
    q := gobble(
      p shifted -e scaled 100
      cutafter makepath(pencircle scaled 2ahlength)
    ) cuttings;
    (q rotated 90 & reverse q rotated 270) shifted e
  enddef;

  vardef barTail expr p =
    save q,e; path q; pair e;
    e := point 0 of p;
    q := gobble(
      p shifted -e scaled 100
      cutbefore makepath(pencircle scaled 2ahlength)
    ) cuttings;
    (reverse q rotated 90 & q rotated 270) shifted e
  enddef;
 
  % The "drawarrow" implementation is based upon that in plain.mp (see above)
  %
  def addArrow
    (expr fRow, fCol, tRow, tCol)
    (expr fromTails, toHeads)
    (expr aLabel)
    (suffix position)
    (expr bend) =
    aLine  := w[fRow][fCol] .. w[tRow][tCol];
    aBegin := aLine intersectionpoint objLabel[fRow][fCol] enlarged 0.15cm ;
    aEnd   := aLine intersectionpoint objLabel[tRow][tCol] enlarged 0.15cm ;
    path anArrow;
    anArrow := aBegin .. aEnd;
    %
    % a local "drawarrow" implementation
    %
    draw anArrow ;
    if 0 < length(fromTails) :
      for i = 1 upto length(fromTails) :
        numeric aTail;
        aTail := ASCII (substring(i-1,i) of fromTails);
        if aTail = 124 : % "|"
          draw barTail anArrow ;
        elseif aTail = 111 : % "o"
          filldraw dotTail anArrow ;
        elseif aTail = 62 : % ">"
          filldraw firstArrowTail anArrow ;
        elseif aTail = 60 : % "<"
          filldraw firstReversedArrowTail anArrow ;
        elseif aTail = 93 : % "]"
          filldraw secondArrowTail anArrow ;
        elseif aTail = 91 : % "["
          filldraw secondReversedArrowTail anArrow ;
        fi ;
      endfor ;
    fi ;
    if 0 < length(toHeads) :
      for i = 1 upto length(toHeads) :
        numeric aHead;
        aHead := ASCII (substring(i-1,i) of toHeads);
        if aHead = 124 : % "|"
          draw barHead anArrow ;
        elseif aHead = 111 : % "o"
          filldraw dotHead anArrow ;
        elseif aHead = 62 : % ">"
          filldraw firstArrowHead anArrow ;
        elseif aHead = 60 : % "<"
          filldraw firstReversedArrowHead anArrow ;
        elseif aHead = 93 : % "]"
          filldraw secondArrowHead anArrow ;
        elseif aHead = 91 : % "["
          filldraw secondReversedArrowHead anArrow ;
        fi ;
      endfor ;
    fi ;
    if 0 < length(aLabel) :
      picture aLabelPic;
      aLabelPic := thelabel("$"&aLabel&"$", origin ) ;
      pair aLabelPt;
      aLabelPt := point 0.5 of anArrow;
      label position (aLabelPic, aLabelPt) ;
    fi;
  enddef;
\stopMPdefinitions

% from file: conclusion.tex after line: 0

\protect \endinput